(* ****************************************************************** *)
(*                                                                    *)
(*                            Automatic.gen                           *)
(*                                                                    *)
(* ****************************************************************** *)

(*
Author:              Frederik Orellana 1997

Summary:             Generic model for FeynArts

Mathematica Version: 3.0

Requirements:        FeynArts > 2, PHI, FeynCalc > 3

Description:         The coupling vector are loaded from files
						generated by PHI
*)

(* ****************************************************************** *)

$GenericModel = "Automatic";

(* ****************************************************************** *)

(* The minuses for outgoing particles are removed *)

$VerticesSpecifications1:=($VerticesSpecifications/.-qu_[q__]->qu[q]);

(* ****************************************************************** *)

(* Standard definitions for all PHI particle types *)

PropagatorType[$ScalarHeads]=Straight;
PropagatorType[$VectorHeads]=Sine;
(*PropagatorType[$FermionHeads]=Dashing[{0.003,0.006}];*)
(*FA seems to have lost some flexibility in costumizing the graphics*)
PropagatorType[$FermionHeads]=ScalarDash;

PropagatorArrow[$ParticleHeads]=None;

KinematicIndices[$ScalarHeads] := {};
KinematicIndices[$FermionHeads] := {};
KinematicIndices[$VectorHeads] := {Lorentz};

TheLabel[Index[Lorentz,i_]] :=
$CouplingLorentzIndicesString<>ToString[i];

(* ****************************************************************** *)

(*
The function GenProps[p]
gives the propagator description for the particle type p.
Standard definitions are used.
Notice that the setting of $PropagatorMassesStates determines the
renormalization state of the mass used for the propagator of each
particle
*)

(* The condition added to allow redifining propagators
before loading FeynArts *)
If[And@@((Head[GenProps[#]]===GenProps)&/@
({$ScalarHeads /. Alternatives -> Sequence})),
GenProps[a:$ScalarHeads]:={
AnalyticalPropagator[External][ s a[i,p] ] == 1,
AnalyticalPropagator[Internal][ s a[i,p] ] ==
I*PropagatorDenominator[p,Mass[a[i]]]}];

If[And@@((Head[GenProps[#]]===GenProps)&/@
({$VectorHeads /. Alternatives -> Sequence})),
GenProps[a:$VectorHeads]:={
AnalyticalPropagator[External][ s a[i, mom, {li2}] ] ==
PolarizationVector[ a[i], mom, li2 ],
AnalyticalPropagator[Internal][ s a[i,mom,{li1}->{li2}] ] ==
I*PropagatorDenominator[ mom , Mass[a[i]] ]*
(-MetricTensor[li1, li2])}];

If[And@@((Head[GenProps[#]]===GenProps)&/@
({$FermionHeads /. Alternatives -> Sequence})),
GenProps[a:$FermionHeads]:={
AnalyticalPropagator[External][ s a[i, mom] ] ==
NonCommutative[
(*Tag, so WFRenormalize can do its thing*)
(*DiracSpinor[
-mom, Mass[ a[i] ], Sequence @@ Drop[{i},1] ]*)
Phi`Couplings`Private`propSpinor[
-mom, Mass[ a[i] ], Sequence @@ Drop[{i},1] ] ],
AnalyticalPropagator[Internal][ s a[i,mom] ] ==
NonCommutative[(*DiracGamma[ -mom ] + Mass[a[i]]*)
Phi`Couplings`Private`propGamma[
-mom, Mass[a[i]]] ]*
I*PropagatorDenominator[ mom , Mass[a[i]] ]}];

(* ****************************************************************** *)

(* allfields is all field-types in $VerticesSpecifications
(that is, Pion[0], Pion[1], ... are not distinguished) *)
(* Change 20/3-1999 - mixing fields must also be included in this list *)

allfields=
Union[Head/@Union[
Flatten[Transpose[Transpose[
$VerticesSpecifications1][[1]]/.Rule->List][[2]]],
If[Length[$MixingFields]>0,Transpose[$MixingFields/.Rule->List][[1]],{}]]];

(* The function GenProps is used to create propagator definitions
for all particle types *)

M$GenericPropagators = Flatten[GenProps/@allfields];

(* ****************************************************************** *)

(* Only vector-type particles have Lorentz index *)

kineindex[a:$VectorHeads,i_]:={ToExpression[
$CouplingLorentzIndicesString<>ToString[i]]};
kineindex[a:$ScalarHeads,i_]:=Sequence[];
kineindex[a:$FermionHeads,i_]:=Sequence[];

(*
The coupling vectors are read from the files specified in
$VerticesSpecifications.  The left-hand side
(genericfieldsmomenta) of the defintion and the field
configuration (genericfields) are created with the fields
from $VerticesSpecifications.  The symmetry sign is also
taken from $VerticesSpecifications
*)

(* listrepl substitutes the list PerturbationOrder with
one element at a time - to pass it to XName *)

(*Added 7/6-2000 to allow a list of non-Automatic XFileName's*)
listrepl[{aa___,PerturbationOrder->b_List,
bb___,XFileName->xn_List,cc___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};

listrepl[{aa___,XFileName->xn_List,
bb___,PerturbationOrder->b_List,cc___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};

(**)

listrepl[{aa___,PerturbationOrder->b_List,bb___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb};

(
olddir=Directory[];
SetDirectory[$HEPDir];
SetDirectory["FeynCalc"];
SetDirectory["Phi"];
SetDirectory["CouplingVectors"];

Do[

Do[

(* The coupling vectors are loaded into an array *)

gloadfile[filenr] = XName[listrepl[
$VerticesSpecifications1[[repp]],filenr]]<>".Gen";

fpath = ToFileName[{$FeynCalcDirectory, "Phi", "CouplingVectors"}, gloadfile[filenr]];

VerbosePrint[1,repp," ",filenr,
" Loading generic coupling from ",fpath];

genericcouplingvector[repp,filenr] = Get[fpath];

VerbosePrint[2, genericcouplingvector[repp,filenr]],

{filenr,Length[PerturbationOrder/.
$VerticesSpecifications1[[repp]]]}];

(* The array is simply joined (flattened) *)

genericcouplingvector[repp] =
Join@@(Table[genericcouplingvector[repp,filenr],
{filenr,Length[PerturbationOrder/.
$VerticesSpecifications1[[repp]]]}]);

genericfields[repp] =
Table[ ToExpression["s"<>ToString[rep]]*
$VerticesSpecifications1[[repp,1,2,rep,0]][
ToExpression["nr"<>ToString[rep]] ],
{rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];

genericfieldsmomenta[repp] =
Table[ ToExpression["s"<>ToString[rep]]*
$VerticesSpecifications1[[repp,1,2,rep,0]][
ToExpression["nr"<>ToString[rep]],
ToExpression[$CouplingMomentumVariablesString<>ToString[rep]],
kineindex[$VerticesSpecifications1[[repp,1,2,rep,0]],rep] ],
{rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];,

{repp,Length[$VerticesSpecifications1]}];

SetDirectory[olddir];);

csign[rr_]:=CouplingSign/.$VerticesSpecifications1[[rr]];

(* ****************************************************************** *)

(* The loaded coupling vectors and the constructed left-hand sides are
used for constructing the coupling definitions *)

M$GenericCouplings  =
Union[Table[
AnalyticalCoupling@@(genericfieldsmomenta[repp])==
(G[csign[repp]]@@genericfields[repp]).genericcouplingvector[repp],
{repp,Length[$VerticesSpecifications1]}]];

(* Merge coupling vectors belonging to the same vertex *)

multVertPosG = Position[M$GenericCouplings,#[[1]]]& /@ M$GenericCouplings;

multVertsG = (Extract[M$GenericCouplings,#[[1]]]& /@ #)& /@ multVertPosG;

vertsG =  Union[(#[[1,1]] == merge @@ ((#[[2]])& /@ #))& /@ multVertsG];

M$GenericCouplings=
	vertsG /. a:merge[(G[_][__].{__})..] :> a[[1,1]].(Join @@ ((#[[2]])& /@ a));

FixCouplingSigns;

(* ****************************************************************** *)

(* FermionFlipRules: for a certain mapping of Fermion fields in a coupling
we have to know which operations to perform.
OVERALL minus signs of the flipping are generated by defining G to be
anti-symmetric (G[-1]).
In this model, flip rules are applied for FSS- and FFV-couplings.
FSS contains only omega[+/-], so none of the rules matches. FVV
is antisymmetric and the rules match, resulting in
ga_mu omega[+] ->  - ga_mu omega[-]
ga_mu omega[-] ->  - ga-mu omega[+]. *)

M$FermionFlipRule[ 1->2, 2->1, ___ ] =
{
NonCommutative[ DiracGamma[li_],ChiralityProjector[ 1]] :>
- NonCommutative[ DiracGamma[li], ChiralityProjector[-1] ],
NonCommutative[ DiracGamma[li_],ChiralityProjector[-1]] :>
- NonCommutative[ DiracGamma[li], ChiralityProjector[ 1] ]
};

(* This was cleared in a release of FeynArts-3.7. Without it, Dirac traces are not taken *)
$FermionLines = True;
(* This should speed up a bit *)
$SparseCouplings = True;

(* ****************************************************************** *)

M$LastGenericRules = {
(* Outgoing vector bosons: throw away signs of momenta *)
PolarizationVector[
p_, _. k:(FourMomentum[ Outgoing, i_Integer ]), li_ ] :>
Conjugate[PolarizationVector][ p, k, li ] ,

(* for the case of self-energies *)
PolarizationVector[
p_, k:(- FourMomentum[ Incoming, 1 ]), li_ ] :>
Conjugate[PolarizationVector][ p, k, li ],

(* relicts of the truncation of spinors: *)

Dot[ 1, line__, 1 ] :> Dot[ line ],
Dot[ 1, 1 ] :> 1 };

(**)
